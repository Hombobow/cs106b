#!/usr/bin/env -S bash
# auto_commit.sh
# Usage:
#   Build hook (no launch):   ./auto_commit.sh --build-hook [REPO_ROOT] [TARGET_NAME] [DESTDIR]
#   Run (launch + capture):   ./auto_commit.sh --run [--force-run] [--exe PATH] [REPO_ROOT] [TARGET_NAME] [DESTDIR]

########################################
# Course settings (customize as needed)
########################################
STUDENT="jackylaw"
ASSIGNMENT="7"

set -euo pipefail
# set -x

########################################
# Modes & flags
########################################
MODE="${1:-}"; [[ $# -gt 0 ]] && shift || true
FORCE_RUN=0
EXE_OVERRIDE=""

# Parse flags that can appear before positional args
while [[ $# -gt 0 ]]; do
  case "$1" in
    --run|--build-hook) MODE="$1"; shift ;;
    --force-run|--always|--no-skip) FORCE_RUN=1; shift ;;
    --exe) EXE_OVERRIDE="${2:-}"; shift 2 ;;
    *) break ;; # first non-flag is REPO_ROOT
  esac
done

# Default mode if omitted
if [[ "${MODE:-}" != "--run" && "${MODE:-}" != "--build-hook" ]]; then
  MODE="--run"
fi

########################################
# Positional args (optional)
########################################
REPO_ROOT="${1:-$(pwd)}"
TARGET_NAME="${2:-}"
DESTDIR="${3:-$REPO_ROOT}"

cd "$REPO_ROOT"

########################################
# Helpers
########################################
require_git() {
  if ! command -v git >/dev/null 2>&1; then
    echo "Error: git not found on PATH." >&2
    exit 1
  fi
}

ensure_repo() {
  if [[ ! -d .git ]]; then
    echo "No git repo found. Initializing one..."
    git init
    git config user.name "CS106B Student"
    git config user.email "jackylaw@stanford.edu"
    if [[ ! -f .gitignore ]]; then
      cat > .gitignore <<'EOF'
output/*
!output/welcome_output_*.txt
*.zip
build*/
**/build*/
**/*.app/
EOF
      git add .
      git commit -m "Initial commit (autogenerated)"
    fi
  fi
}

watched_files() {
  # echo each path that exists (one per line)
  local c=("NameHash.cpp" "Sources/NameHash.cpp")
  local p
  for p in "${c[@]}"; do
    [[ -f "$p" ]] && printf '%s\n' "$p"
  done
}

should_skip_run() {
  # Return 0 (true) iff HEAD exists AND watched files unchanged
  # args: watched files...
  git rev-parse --verify HEAD >/dev/null 2>&1 || return 1
  [[ $# -eq 0 ]] && return 1
  local s
  s="$(git status --porcelain -- "$@" 2>/dev/null || true)"
  [[ -z "$s" ]]
}

find_executable() {
  # Use override if provided and executable
  if [[ -n "$EXE_OVERRIDE" && -x "$EXE_OVERRIDE" ]]; then
    echo "$EXE_OVERRIDE"; return 0
  fi

  local uname_s exe app
  uname_s="$(uname -s || echo unknown)"
  if [[ "$uname_s" == "Darwin" ]]; then
    exe="$DESTDIR/$TARGET_NAME.app/Contents/MacOS/$TARGET_NAME"
    if [[ -z "$TARGET_NAME" || ! -x "$exe" ]]; then
      app="$(ls -dt "$DESTDIR"/*.app 2>/dev/null | head -n1 || true)"
      if [[ -n "$app" ]]; then
        if [[ -n "$TARGET_NAME" && -x "$app/Contents/MacOS/$TARGET_NAME" ]]; then
          exe="$app/Contents/MacOS/$TARGET_NAME"
        else
          # first binary in MacOS/
          local bin
          bin="$(ls -1 "$app/Contents/MacOS/" 2>/dev/null | head -n1 || true)"
          [[ -n "$bin" ]] && exe="$app/Contents/MacOS/$bin"
        fi
      fi
    fi
  else
    exe="$DESTDIR/$TARGET_NAME"
    if [[ -z "$TARGET_NAME" || ! -x "$exe" ]]; then
      exe="$(find "$DESTDIR" -maxdepth 1 -type f -perm -u+x | head -n1 || true)"
    fi
  fi
  echo "${exe:-}"
}

counter_bump() {
  local f=".autocommit_counter.txt"
  local n=0
  if [[ -f "$f" ]] && head -n1 "$f" | grep -Eq '^[0-9]+$'; then
    n="$(head -n1 "$f")"
  fi
  n=$((n+1))
  echo "$n" > "$f"
  echo "$n"
}

commit_and_push() {
  local count="$1" output_file="$2"; shift 2
  local ts commit_source
  ts="$(date '+%Y-%m-%d %H:%M:%S')"
  commit_source="$(basename "$REPO_ROOT")"

  git add -f -- "$output_file" || true
  git add -- ".autocommit_counter.txt" "auto_commit.sh" || true
  if [[ $# -gt 0 ]]; then
    git add -f -- "$@" || true
  fi

  git status --porcelain
  if git commit -a -m "Auto-commit (Mac) #$count from $commit_source at $ts"; then
    :
  else
    echo "[auto_commit] Nothing to commit."
  fi

  if git remote get-url origin >/dev/null 2>&1; then
    git push -u origin HEAD & 
  else
    echo "[auto_commit] No 'origin' remote configured; skipping push."
  fi
}

package_and_upload() {
  local count="$1"
  local ts_file stage_root outer_name outer_dir inner_dir zip_name zip_path
  ts_file="$(date '+%Y-%m-%d_%H-%M-%S')"
  stage_root="$(mktemp -d "${TMPDIR:-/tmp}/pensieve_stage.XXXXXX")"

  outer_name="submission_${STUDENT}_asg${ASSIGNMENT}_${ts_file}"
  outer_dir="$stage_root/$outer_name"
  inner_dir="$outer_dir/pensieve_${STUDENT}"

  mkdir -p "$inner_dir"
  rsync -a --exclude '*.zip' "$REPO_ROOT/" "$inner_dir/"

  zip_name="${outer_name}.zip"
  zip_path="$stage_root/$zip_name"

  echo "Creating archive: $zip_path"
  rm -f "$zip_path"
  ( cd "$stage_root" && zip -qr "$zip_name" "$outer_name" )

  echo "Uploading to Pensieve..."
  curl --progress-bar \
       -F "file=@${zip_path}" \
       -F "sunet=${STUDENT}" \
       -F "assignment=${ASSIGNMENT}" \
       https://pincs.stanford.edu/cgi-bin/pensieve/upload-zip.cgi \
    || echo "Upload failed."

  rm -rf "$stage_root"
}

########################################
# Main
########################################
require_git
ensure_repo

# Build WATCH array portably (after helpers are defined)
declare -a WATCH=()
while IFS= read -r line; do
  [[ -n "$line" ]] && WATCH+=("$line")
done < <(watched_files || true)

if [[ "$MODE" == "--build-hook" ]]; then
  # Build step: commit if something changed; do NOT run the app here.

  # If absolutely nothing changed (tracked files), skip creating noise commits.
  if [[ -z "$(git status --porcelain)" ]]; then
    echo "[auto_commit] no changes after build; skipping commit."
    exit 0
  fi

  COUNT="$(counter_bump)"

  OUTPUT_DIR="$REPO_ROOT/output"
  mkdir -p "$OUTPUT_DIR"
  OUTPUT_FILE="$OUTPUT_DIR/build_output_${COUNT}.txt"

  {
    echo "Build hook auto-commit #$COUNT"
    date '+%Y-%m-%d %H:%M:%S %z'
    echo "Target: ${TARGET_NAME:-<unknown>}"
    echo "Destdir: $DESTDIR"
    echo "Watched files present:"
    if ((${#WATCH[@]:-0} > 0)); then
      for w in "${WATCH[@]}"; do echo "  - $w"; done
    else
      echo "  (none)"
    fi
    echo
    echo "git status (pre-commit):"
    git status --porcelain=v1
  } > "$OUTPUT_FILE"

  # Reuse commit function; it will no-op if nothing changed by the time of commit.
  if ((${#WATCH[@]:-0} > 0)); then
    commit_and_push "$COUNT" "$OUTPUT_FILE" "${WATCH[@]}"
  else
    commit_and_push "$COUNT" "$OUTPUT_FILE"
  fi
  package_and_upload "$COUNT"

  exit 0
fi

# MODE == --run
if [[ "$FORCE_RUN" -ne 1 ]]; then
  if ((${#WATCH[@]:-0} > 0)) && should_skip_run "${WATCH[@]}"; then
    echo "[auto_commit] watched sources unchanged; skipping app launch + commit."
    exit 0
  fi
fi

COUNT="$(counter_bump)"

OUTPUT_DIR="$REPO_ROOT/output"
mkdir -p "$OUTPUT_DIR"
OUTPUT_FILE="$OUTPUT_DIR/welcome_output_${COUNT}.txt"

EXE="$(find_executable)"
if [[ -z "$EXE" || ! -x "$EXE" ]]; then
  echo "Executable not found or not executable: ${EXE:-<empty>}" >&2
  exit 1
fi

export SCREENSHOT_MODE=1
UNAME="$(uname -s || echo unknown)"
if command -v script >/dev/null 2>&1; then
  if [[ "$UNAME" == "Darwin" ]]; then
    script -q "$OUTPUT_FILE" bash -lc "\"$EXE\""
  else
    script -q -c "\"$EXE\"" "$OUTPUT_FILE"
  fi
else
  "$EXE" >"$OUTPUT_FILE" 2>&1 || true
fi

[[ ! -f "$OUTPUT_FILE" ]] && { echo "App output not captured. Aborting commit." >&2; exit 1; }

if ((${#WATCH[@]:-0} > 0)); then
  commit_and_push "$COUNT" "$OUTPUT_FILE" "${WATCH[@]}"
else
  commit_and_push "$COUNT" "$OUTPUT_FILE"
fi
package_and_upload "$COUNT"



